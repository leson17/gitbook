# 浏览器渲染原理 -- DOM树、CSSOM、分层和合成机制

[](#DOM-树 "DOM 树")DOM 树
=======================

[](#什么是-DOM "什么是 DOM")什么是 DOM
-----------------------------

从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用。

*   从页面的视角来看，DOM 是生成页面的基础数据结构。
*   从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。
*   从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。

简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。

[](#DOM-树如何生成 "DOM 树如何生成")DOM 树如何生成
-----------------------------------

在渲染引擎内部，有一个叫HTML 解析器（`HTMLParser`）的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。所以这里我们需要先要搞清楚 HTML 解析器是怎么工作的。

HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？

HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。

详细的流程：网络进程接收到响应头之后，会根据响应头中的`content-type`字段来判断文件的类型，比如`content-type`的值是`text/html`，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并将其解析为 DOM。

接下来我们就可以来详细聊聊 DOM 的具体生成流程了。

代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img1.png "字节流转换为 DOM")

从图中你可以看出，字节流转换为 DOM 需要三个阶段。

第一个阶段，通过分词器将字节流转换为`Token`。

V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个`Token`。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个`Token`，分为`Tag Token`和文本`Token`。上述 HTML 代码通过词法分析生成的`Token`如下所示：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img2.png "生成的 Token 示意图")

由图可以看出，`Tag Token`又分`StartTag`和`EndTag`，比如`<body>`就是`StartTag`，`</body>`就是`EndTag`，分别对于图中的蓝色和红色块，文本`Token`对应的绿色块。

至于后续的第二个和第三个阶段是同步进行的，需要将`Token`解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。

HTML 解析器维护了一个`Token`栈结构，该`Token`栈主要用来计算节点之间的父子关系，在第一个阶段中生成的`Token`会被按照顺序压到这个栈中。具体的处理规则如下所示：

*   如果压入到栈中的是`StartTag Token`，HTML 解析器会为该`Token`创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。
*   如果分词器解析出来是文本`Token`，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本`Token`是不需要压入到栈中，它的父节点就是当前栈顶`Token`所对应的 DOM 节点。
*   如果分词器解析出来的是`EndTag`标签，比如是`EndTag div`，HTML 解析器会查看`Token`栈顶的元素是否是`StarTag`div，如果是，就将`StartTag div`从栈中弹出，表示该`div`元素解析完成。

通过分词器产生的新`Token`就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。

为了更加直观地理解整个过程，下面我们结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。
 
```html
<html>  
<body>  
 <div>1</div>  
 <div>test</div>  
</body>  
</html>  
```
这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个`Token`是`StartTag html`，解析出来的`Token`会被压入到栈中，并同时创建一个`html`的 DOM 节点，将其加入到 DOM 树中。

这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为`document`的空 DOM 结构，同时会将一个`StartTag document`的`Token`压入栈底。然后经过分词器解析出来的第一个`StartTag html Token`会被压入到栈中，并创建一个`html`的 DOM 节点，添加到`document`上，如下图所示：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img3.png "解析到 StartTag html 时的状态")

然后按照同样的流程解析出来`StartTag body`和`StartTag div`，其`Token`栈和 DOM 的状态如下图所示：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img4.png "解析到 StartTag div 时的状态")

接下来解析出来的是第一个`div`的文本`Token`，渲染引擎会为该`Token`创建一个文本节点，并将该`Token`添加到 DOM 中，它的父节点就是当前`Token`栈顶元素对应的节点，如下图所示：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img5.png "解析出第一个文本 Token 时的状态")

再接下来，分词器解析出来第一个`EndTag div`，这时候 HTML 解析器会去判断当前栈顶的元素是否是`StartTag div`，如果是则从栈顶弹出`StartTag div`，如下图所示：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img6.png "元素弹出 Token 栈示意图")

按照同样的规则，一路解析，最终结果如下图所示：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img7.png "最终解析结果")

通过上面的分析，相信你已经清楚 DOM 是怎么生成的了。不过在实际生产环境中，HTML 源文件中既包含 CSS 和 JavaScript，又包含图片、音频、视频等文件，所以处理过程远比上面这个示范 Demo 复杂。不过理解了这个简单的 Demo 生成过程，我们就可以往下分析更加复杂的场景了。

[](#JavaScript-是如何影响-DOM-生成的 "JavaScript 是如何影响 DOM 生成的")JavaScript 是如何影响 DOM 生成的
--------------------------------------------------------------------------------

```html
<html>  
<body>  
 <div>1</div>  
 <script>  
 let div1 = document.getElementsByTagName('div')\[0\]  
 div1.innerText = 'time.geekbang'  
 </script>  
 <div>test</div>  
</body>  
</html>  
```
在两段`div`中间插入了一段 JavaScript 脚本，这段脚本的解析过程就有点不一样了。`<script>`标签之前，所有的解析流程还是和之前一样，但是解析到`<script>`标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。

通过前面 DOM 生成流程分析，我们已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img8.png "执行脚本时 DOM 的状态")

这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行`script`标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个`div`中的内容，所以执行这段脚本之后，`div`节点内容已经修改为`time.geekbang`了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。

以上过程应该还是比较好理解的，不过除了在页面中直接内嵌 JavaScript 脚本之外，我们还通常需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些，如下面代码：
```js
//foo.js  
let div1 = document.getElementsByTagName('div')\[0\]  
div1.innerText = 'time.geekbang'  
```
```html
<html>  
<body>  
 <div>1</div>  
 <script type="text/javascript" src='foo.js'></script>  
 <div>test</div>  
</body>  
</html>  
```
这段代码的功能还是和前面那段代码是一样的，不过这里把内嵌 JavaScript 脚本修改成了通过 JavaScript 文件加载。其整个执行流程还是一样的，执行到 JavaScript 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。

不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。

再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过`async`或`defer`来标记代码，使用方式如下所示：

```html
<script async type="text/javascript" src='foo.js'></script>  
<script defer type="text/javascript" src='foo.js'></script>  
```
`async`和`defer`虽然都是异步的，不过还有一些差异，使用`async`标志的脚本文件一旦加载完成，会立即执行；而使用了`defer`标记的脚本文件，需要在`DOMContentLoaded`事件之前执行。

现在我们知道了 JavaScript 是如何阻塞 DOM 解析的了，那接下来我们再来看看另外一种情况：
```css
//theme.css  
div {color:blue}  
```
```html
<html>  
 <head>  
 <style src='theme.css'></style>  
 </head>  
<body>  
 <div>1</div>  
 <script>  
 let div1 = document.getElementsByTagName('div')\[0\]  
 div1.innerText = 'time.geekbang' // 需要 DOM  
 div1.style.color = 'red'  // 需要 CSSOM  
 </script>  
 <div>test</div>  
</body>  
</html>  
```
该示例中，JavaScript 代码出现了`div1.style.color = ‘red'`的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。

而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。

所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。

通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。

[](#渲染流水线视角下的-CSS-是如何工作的 "渲染流水线视角下的 CSS 是如何工作的")渲染流水线视角下的 CSS 是如何工作的
====================================================================

我们先结合下面代码来看看最简单的渲染流程：
```css
//theme.css  
div{   
 color : coral;  
 background-color:black  
}  
```
```html
<html>  
<head>  
 <link href="theme.css" rel="stylesheet">  
</head>  
<body>  
 <div>geekbang com</div>  
</body>  
</html>  
```
这两段代码分别由 CSS 文件和 HTML 文件构成，我们来分析下打开这段 HTML 文件时的渲染流水线：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img9.png "含有 CSS 的页面渲染流水线")

下面我们结合上图来分析这个页面文件的渲染流水线。

首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。

当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的`theme.css`文件，并发起`theme.css`的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、`theme.css`文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。

那渲染流水线为什么需要 CSSOM 呢？

和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个 CSSOM 体现在 DOM 中就是`document.styleSheets`。

有了 DOM 和 CSSOM，接下来就可以合成布局树了。等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如`display:none`属性的元素、`head`标签、`script`标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。

这就是在渲染过程中涉及到 CSS 的一些主要流程。

了解了这些之后，我们再来看看稍微复杂一点的场景，还是看下面这段 HTML 代码：
```html
<html>  
<head>  
 <link href="theme.css" rel="stylesheet">  
</head>  
<body>  
 <div>geekbang com</div>  
 <script>  
 console.log('time.geekbang.org')  
 </script>  
 <div>geekbang com</div>  
</body>  
</html>  
```
有了 JavaScript，渲染流水线就有点不一样了，可以参考下面这张渲染流水线图：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img10.png "含有 JavaScript 和 CSS 的页面渲染流水线")

那我们就结合这张图来分析含有外部 CSS 文件和 JavaScript 代码的页面渲染流水线，在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。

不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过`style`标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。

我们再来看看更加复杂一点的情况，如果在`body`中被包含的是 JavaScript 外部引用文件，Demo 代码如下所示：
```css
//theme.css  
div{   
 color : coral;  
 background-color:black  
}  
```
```js
//foo.js  
console.log('time.geekbang.org')  
``` 
```html
<html>  
<head>  
 <link href="theme.css" rel="stylesheet">  
</head>  
<body>  
 <div>geekbang com</div>  
 <script src='foo.js'></script>  
 <div>geekbang com</div>  
</body>  
</html>  
```
从上面代码可以看出来，HTML 文件中包含了 CSS 的外部引用和 JavaScript 外部文件，那它们的渲染流水线是怎样的呢？可参考下图：

![](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/img11.png "含有 JavaScript 文件和 CSS 文件页面的渲染流水线")

从图中可以看出来，在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。

后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。

[](#影响页面展示的因素以及优化策略 "影响页面展示的因素以及优化策略")影响页面展示的因素以及优化策略
-----------------------------------------------------

渲染流水线影响到了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验，所以我们分析渲染流水线的目的就是为了找出一些影响到首屏展示的因素，然后再基于这些因素做一些针对性的调整。

那么接下来我们就来看看从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段。

*   第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。
*   第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。
*   第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。

影响第一个阶段的因素主要是网络或者是服务器处理这块儿。

现在我们重点关注第二个阶段，这个阶段的主要问题是白屏时间，如果白屏时间过久，就会影响到用户体验。为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。

通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。

所以要想缩短白屏时长，可以有以下策略：

*   通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。
*   但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。
*   还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上`sync`或者`defer`。
*   对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。

通过以上策略就能缩短白屏展示的时长了，不过在实际项目中，总是存在各种各样的情况，这些策略并不能随心所欲地去引用，所以还需要结合实际情况来调整最佳方案。

[](#分层和合成机制 "分层和合成机制")分层和合成机制
=============================

DOM 树生成之后，还要经历布局、分层、绘制、合成、显示等阶段后才能显示出漂亮的页面。

[](#显示器是怎么显示图像的 "显示器是怎么显示图像的")显示器是怎么显示图像的
-----------------------------------------

每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。

那么这里显卡做什么呢？

显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。

[](#帧-VS-帧率 "帧 VS 帧率")帧 VS 帧率
-----------------------------

了解了显示器是怎么显示图像的之后，下面我们再来明确下帧和帧率的概念，因为这是后续一切分析的基础。

当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。

大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。

我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。

由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。

要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术。

[](#如何生成一帧图像 "如何生成一帧图像")如何生成一帧图像
--------------------------------

不过在开始之前，我们还需要聊一聊渲染引擎是如何生成一帧图像的。关于其中任意一帧的生成方式，有重排、重绘和合成三种方式。

这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。

相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。

所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。

我们的焦点在合成上，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。

[](#分层和合成 "分层和合成")分层和合成
-----------------------

通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。

为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？

你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。

在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。

考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者`Alpha`渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。

理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。

在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（`Layer Tree`），层树是渲染流水线后续流程的基础结构。

层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成`|Paint BackGroundColor:Black | Paint Circle|`这样的绘制指令列表，绘制过程就完成了。

有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。

需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。

[](#分块 "分块")分块
--------------

如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。

通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。

因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。

为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。

[](#如何利用分层技术优化代码 "如何利用分层技术优化代码")如何利用分层技术优化代码
--------------------------------------------

通过上面的分析，相信你已经理解了渲染引擎是怎么将布局树转换为漂亮图片的，理解其中原理之后，你就可以利用分层和合成技术来优化代码了。

在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。

这时你可以使用`will-change`来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：
```css
.box {  
 will-change: transform, opacity;  
}  
```
这段代码就是提前告诉渲染引擎`box`元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。

所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用`will-change`来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用`will-change`。



## [点击查看原文链接](https://wsq01.github.io/2019/10/16/js/%E6%B7%B1%E5%85%A5/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E2%80%94%E2%80%94DOM%E6%A0%91%E3%80%81CSSOM%E3%80%81%E5%88%86%E5%B1%82%E5%92%8C%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6/)
